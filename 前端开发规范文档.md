# 📖 前后端分离开发最佳实践指南

## 🎯 目标

本文档旨在为舟山天骏石油化工有限公司官网项目建立一套完整的前后端分离开发规范，确保团队协作效率、代码质量和项目可维护性。

## 🏗️ 项目架构规范

### 1. 技术栈选择

#### 前端技术栈
- **核心框架**: React 18 (Hooks + Concurrent Mode)
- **构建工具**: Vite 5.x
- **UI组件库**: Ant Design 5.x
- **状态管理**: Zustand + Immer
- **路由管理**: React Router DOM 6.x
- **HTTP客户端**: Axios + 自定义封装
- **样式方案**: Styled Components + CSS Variables
- **动画库**: Framer Motion
- **图表库**: ECharts for React
- **类型检查**: TypeScript
- **代码规范**: ESLint + Prettier

#### 目录结构规范
```
src/
├── components/           # 可复用组件
│   ├── Common/          # 通用组件
│   ├── Layout/          # 布局组件
│   └── Business/        # 业务组件
├── pages/               # 页面组件
├── services/            # API服务层
├── store/               # 状态管理
├── hooks/               # 自定义Hook
├── utils/               # 工具函数
├── types/               # TypeScript类型定义
├── config/              # 配置文件
├── styles/              # 全局样式
├── assets/              # 静态资源
└── routes/              # 路由配置
```

### 2. 组件设计规范

#### 组件分类
1. **展示组件 (Presentational Components)**
   - 职责：负责UI渲染，不包含业务逻辑
   - 数据来源：通过props传入
   - 状态管理：无内部状态或仅管理UI状态

2. **容器组件 (Container Components)**
   - 职责：负责数据获取和业务逻辑
   - 数据来源：调用API或使用状态管理
   - 状态管理：连接全局状态或管理复杂本地状态

3. **业务组件 (Business Components)**
   - 职责：封装特定业务功能
   - 数据来源：结合API调用和状态管理
   - 状态管理：可能包含业务相关的复杂状态

#### 组件开发原则
- **单一职责**: 每个组件只负责一个功能
- **可复用性**: 设计通用接口，便于在不同场景使用
- **可测试性**: 组件逻辑清晰，便于单元测试
- **性能优化**: 合理使用React.memo、useMemo、useCallback
- **类型安全**: 使用TypeScript定义完整的Props和State类型

## 🌐 API服务层规范

### 1. HTTP客户端封装

#### 核心功能
- 统一的请求/响应拦截器
- 自动化的错误处理
- 请求日志记录（开发环境）
- 请求取消机制
- 请求重试机制
- 缓存策略

#### 使用示例
```javascript
// services/api.js
import { httpMethods } from '../utils/http'

export const userAPI = {
  // 获取用户列表
  getUsers: (params) => httpMethods.get('/users', params),
  
  // 创建用户
  createUser: (data) => httpMethods.post('/users', data),
  
  // 更新用户
  updateUser: (id, data) => httpMethods.put(`/users/${id}`, data),
  
  // 删除用户
  deleteUser: (id) => httpMethods.delete(`/users/${id}`),
  
  // 文件上传
  uploadAvatar: (file) => {
    const formData = new FormData()
    formData.append('file', file)
    return httpMethods.upload('/users/avatar', formData)
  }
}
```

### 2. API调用规范

#### 请求格式
- **URL**: RESTful风格，使用名词复数形式
- **方法**: GET/POST/PUT/PATCH/DELETE
- **参数**: 
  - 查询参数：`?page=1&size=10`
  - 请求体：JSON格式
  - 路径参数：`/users/{id}`
- **头部**: 
  - Content-Type: application/json
  - Authorization: Bearer {token}
  - Accept-Language: zh-CN

#### 响应格式
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {},
  "timestamp": "2024-01-01T00:00:00Z",
  "requestId": "uuid"
}
```

#### 错误处理
- HTTP状态码遵循标准规范
- 业务错误通过code字段区分
- 统一的错误提示和用户反馈

## 🗃️ 状态管理规范

### 1. Zustand Store设计

#### Store结构
```javascript
// store/userStore.js
import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'

export const useUserStore = create(
  persist(
    immer((set, get) => ({
      // 状态
      users: [],
      currentUser: null,
      loading: false,
      error: null,
      
      // Actions
      fetchUsers: async () => {
        set((state) => {
          state.loading = true
        })
        
        try {
          const users = await userAPI.getUsers()
          set((state) => {
            state.users = users
            state.loading = false
          })
        } catch (error) {
          set((state) => {
            state.error = error
            state.loading = false
          })
        }
      },
      
      // 重置状态
      reset: () => set({
        users: [],
        currentUser: null,
        loading: false,
        error: null
      })
    })),
    {
      name: 'user-storage',
      partialize: (state) => ({
        users: state.users
      })
    }
  )
)
```

### 2. 状态使用规范

#### 数据获取流程
1. 页面组件调用自定义Hook
2. Hook调用Store Action
3. Action调用API服务
4. API返回数据更新Store
5. 组件重新渲染显示数据

#### 状态持久化
- 重要状态使用localStorage持久化
- 敏感信息不存储在客户端
- 合理设置过期时间

## 🪝 自定义Hook规范

### 1. Hook设计原则

#### 单一职责
每个Hook只负责一个特定功能：
```javascript
// ✅ 正确示例
const { data, loading, error, refetch } = useAPI(api.getUser)
const { visible, open, close } = useModal()
const { uploading, progress, uploadFile } = useFileUpload()

// ❌ 错误示例
const { data, loading, error, visible, open, close } = useComplexHook()
```

#### 命名规范
- 以`use`开头
- 动词+名词形式
- 语义清晰

```javascript
useAPI()          // API调用
useForm()         // 表单处理
useModal()        // 模态框
usePagination()   // 分页
useSearch()       // 搜索
useClipboard()    // 剪贴板
```

### 2. 常用Hook示例

#### 数据获取Hook
```javascript
const { data, loading, error, refetch } = useAPI(api.getUsers, {
  immediate: true,
  onSuccess: (users) => {
    console.log('用户列表获取成功:', users)
  }
})
```

#### 表单Hook
```javascript
const { form, loading, handleSubmit } = useForm({
  initialValues: { name: '', email: '' },
  onSubmit: async (values) => {
    await userAPI.createUser(values)
  }
})
```

## 🎨 样式规范

### 1. CSS变量系统

#### 全局变量
```css
:root {
  /* 颜色系统 */
  --color-primary: #004C97;
  --color-secondary: #FFD100;
  
  /* 字体系统 */
  --font-size-base: 16px;
  --font-family: 'Inter', sans-serif;
  
  /* 间距系统 */
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  
  /* 圆角系统 */
  --border-radius: 4px;
  
  /* 阴影系统 */
  --shadow-base: 0 2px 8px rgba(0, 0, 0, 0.1);
}
```

### 2. Styled Components使用

#### 组件样式
```javascript
import styled from 'styled-components'

const StyledCard = styled.div`
  background: white;
  border-radius: var(--border-radius);
  box-shadow: var(--shadow-base);
  padding: var(--spacing-md);
  
  .card-title {
    font-size: var(--font-size-lg);
    font-weight: 600;
    margin-bottom: var(--spacing-sm);
  }
  
  @media (max-width: 768px) {
    padding: var(--spacing-sm);
  }
`
```

## 🛡️ 错误处理规范

### 1. 全局错误边界

#### React错误边界
```javascript
// components/ErrorBoundary.jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error) {
    return { hasError: true }
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo)
    // 上报错误到监控服务
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback />
    }
    return this.props.children
  }
}
```

### 2. 错误分类处理

#### 网络错误
- 超时处理
- 断网重连
- 请求重试

#### 业务错误
- 统一错误码
- 用户友好提示
- 错误日志记录

#### 前端错误
- 组件渲染错误
- 类型错误
- 逻辑错误

## 🧪 测试规范

### 1. 测试策略

#### 单元测试
- 组件单元测试
- 工具函数测试
- Hook测试
- Store测试

#### 集成测试
- 页面流程测试
- API调用测试
- 用户交互测试

#### 端到端测试
- 关键业务流程
- 跨页面导航
- 表单提交验证

### 2. 测试工具

#### Jest + React Testing Library
```javascript
// __tests__/UserCard.test.js
import { render, screen } from '@testing-library/react'
import UserCard from '../components/UserCard'

test('renders user name', () => {
  const user = { name: '张三', email: 'zhangsan@example.com' }
  render(<UserCard user={user} />)
  
  expect(screen.getByText('张三')).toBeInTheDocument()
  expect(screen.getByText('zhangsan@example.com')).toBeInTheDocument()
})
```

## 🚀 性能优化规范

### 1. 代码分割

#### 路由级别分割
```javascript
const Home = lazy(() => import('../pages/Home'))
const About = lazy(() => import('../pages/About'))

<Routes>
  <Route path="/" element={
    <Suspense fallback={<Loading />}>
      <Home />
    </Suspense>
  } />
</Routes>
```

#### 组件级别分割
```javascript
const EChartsMap = lazy(() => import('../components/EChartsMap'))

<Suspense fallback={<Spin />}>
  <EChartsMap />
</Suspense>
```

### 2. 懒加载优化

#### 图片懒加载
```javascript
import { LazyImage } from '../components/LazyImage'

<LazyImage 
  src="large-image.jpg" 
  alt="描述"
  placeholder={<Skeleton />}
/>
```

#### 数据懒加载
```javascript
const { data, loading } = useAPI(api.getUsers, {
  immediate: false
})

// 用户滚动到底部时加载更多
useEffect(() => {
  const handleScroll = () => {
    if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 1000) {
      loadMore()
    }
  }
  
  window.addEventListener('scroll', handleScroll)
  return () => window.removeEventListener('scroll', handleScroll)
}, [])
```

## 🔒 安全规范

### 1. XSS防护

#### 输入验证
```javascript
// utils/sanitizer.js
export const sanitizeInput = (input) => {
  if (typeof input !== 'string') return input
  return input
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
}
```

#### 输出转义
```javascript
// components/DangerousContent.jsx
import DOMPurify from 'dompurify'

const DangerousContent = ({ htmlContent }) => {
  const sanitizedContent = DOMPurify.sanitize(htmlContent)
  return <div dangerouslySetInnerHTML={{ __html: sanitizedContent }} />
}
```

### 2. CSRF防护

#### 请求头验证
```javascript
// utils/http.js
http.interceptors.request.use(config => {
  const csrfToken = getCookie('csrf_token')
  if (csrfToken) {
    config.headers['X-CSRF-Token'] = csrfToken
  }
  return config
})
```

## 📊 监控规范

### 1. 性能监控

#### 关键指标
- 页面加载时间
- 首屏渲染时间
- 用户交互延迟
- API响应时间

#### 监控工具集成
```javascript
// utils/performance.js
export const measurePerformance = () => {
  if ('performance' in window) {
    const perfData = performance.getEntriesByType('navigation')[0]
    console.log('页面加载时间:', perfData.loadEventEnd - perfData.fetchStart)
  }
}
```

### 2. 错误监控

#### 前端错误收集
```javascript
// utils/errorReporter.js
export const reportError = (error, context = {}) => {
  const errorInfo = {
    message: error.message,
    stack: error.stack,
    url: window.location.href,
    userAgent: navigator.userAgent,
    timestamp: new Date().toISOString(),
    context
  }
  
  // 发送到监控服务
  fetch('/api/errors', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(errorInfo)
  }).catch(() => {
    // 降级处理
    console.error('错误上报失败:', errorInfo)
  })
}
```

## 📋 开发流程规范

### 1. Git工作流

#### 分支策略
- `main`: 生产环境分支
- `develop`: 开发环境分支
- `feature/*`: 功能开发分支
- `hotfix/*`: 紧急修复分支
- `release/*`: 发布准备分支

#### 提交规范
```bash
# 功能开发
git checkout -b feature/user-management
git add .
git commit -m "feat: 添加用户管理功能"

# 修复bug
git checkout -b hotfix/login-error
git add .
git commit -m "fix: 修复登录错误问题"

# 文档更新
git commit -m "docs: 更新API文档"
```

### 2. 代码审查

#### 审查清单
- [ ] 代码符合规范
- [ ] 功能实现正确
- [ ] 错误处理完善
- [ ] 性能优化考虑
- [ ] 测试用例覆盖
- [ ] 文档更新完整

## 🎯 质量保证

### 1. 代码质量检查

#### ESLint配置
```json
{
  "extends": [
    "react-app",
    "react-app/jest"
  ],
  "rules": {
    "react-hooks/exhaustive-deps": "warn",
    "no-console": "warn",
    "no-debugger": "error"
  }
}
```

#### TypeScript配置
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true
  }
}
```

### 2. 持续集成

#### CI/CD流程
1. 代码提交触发构建
2. 运行代码检查和测试
3. 构建生产版本
4. 自动化部署到测试环境
5. 手动部署到生产环境

## 📈 项目维护

### 1. 依赖管理

#### 定期更新
```bash
# 检查过时依赖
npm outdated

# 更新依赖
npm update

# 安全漏洞修复
npm audit fix
```

#### 依赖清理
```bash
# 分析依赖使用情况
npx depcheck

# 移除未使用依赖
npm uninstall unused-package
```

### 2. 性能监控

#### 定期检查
- 页面加载性能
- Bundle大小分析
- 内存使用情况
- 用户体验指标

通过遵循以上规范，可以确保项目的高质量、可维护性和团队协作效率。所有开发人员都应该熟悉并遵守这些规范。